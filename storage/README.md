# Storage

Pods by themselves are useful, but many workloads require exchanging data between containers, or persisting some
form of data.

For this we have Volumes, Persistent Volumes, Persistent Volume Claims, and Storage Classes.


# Index

* [Before you Begin](#before-you-begin)
* [Volumes](#volumes)
  * [Exercise: Using Volumes with Pods](#exercise-using-volumes-with-pods)
* [Persistent Volumes and Claims](#persistent-volumes-and-claim)
  * [Exercise: Understanding Persistent Volumes and Claims](#exercise-understanding-persistent-volumes-and-claims)
  * [Exercise: Using PersistentVolumeClaims](#exercise-using-persistentvolumeclaims)
* [Storage Classes](#storage-classes)
  * [Exercise: Exploring StorageClasses](#exercise-exploring-storageclasses)
* [Cleaning Up](#cleaning-up)
* [Helpful Resources](#helpful-resources)


---

# Before you Begin

Minikube comes with a default storage-class and provisioner that can get in the way when trying to explore how
Storage is used within a Kubernetes cluster. For these exercises, it should be removed.

```
$ minikube addons disable addon-manager
$ kubectl delete po storage-provisioner -n kube-system
```

---

# Volumes
Volumes within Kubernetes are storage that is tied to the Pod’s Lifecycle.

A pod can have one or more type of volumes attached to it.
These volumes are consumable by any of the containers within the pod.

They can survive Pod restarts; however their durability beyond that is dependent on the Volume Type.

---

### Exercise: Using Volumes with Pods
**Objective:** Understand how to add and reference volumes to a Pod and their containers.

---

1) Create a Pod with from the manifest `manifests/volume-example.yaml` or the yaml below.

```
$ kubectl create -f manifests/volume-example.yaml
```

**manifests/volume-example.yaml**
```
apiVersion: v1
kind: Pod
metadata:
  name: volume-example
spec:
  containers:
  - name: nginx
    image: nginx:stable-alpine
    volumeMounts:
    - name: html
      mountPath: /usr/share/nginx/html
      readOnly: true
  - name: content
    image: alpine:latest
    volumeMounts:
    - name: html
      mountPath: /html
    command: ["/bin/sh", "-c"]
    args:
      - while true; do
          date >> /html/index.html;
          sleep 5;
        done
  volumes:
  - name: html
    emptyDir: {}
```
Note the relationship between `volumes` in the Pod spec, and the `volumeMounts` directive in each container.

2) Exec into `content` container within the `volume-example` Pod, and `cat` the `html/index.html` file.
```
$ kubectl exec volume-example -c content -- /bin/sh -c "cat /html/index.html"
```
You should see a list of date time-stamps. This is generated by script being used by the entrypoint of the content
container.

3) Now do the same within the `nginx` container, using `cat` to see the content of `/usr/share/nginx/html/index.html`
example.
```
$ kubectl exec volume-example -c nginx -- /bin/sh -c "cat /usr/share/nginx/html/index.html"
```
You should see the same file.

4) Now try to append "nginx" to `index.html` from the `nginx` container.
```
$ kubectl exec volume-example -c nginx -- /bin/sh -c "echo nginx >> /usr/share/nginx/html/index.html"
```
It should error out and complain about the file being read only. The `nginx` container has no reason to write to the
file. That job is handled by the `content` container.

---

**Summary:** Pods may have multiple volumes using different volume types. Those volumes in turn can be  mounted to one
 or more containers within the Pod by adding them to the `volumeMounts` list by referencing their name and supplying
their `mountPath`. Volumes may be mounted both read-write or read-only depending on the use-case for the application,
enabling a variety of use-cases.

---

[Back to Index](#index)

---
---


# Persistent Volumes and Claims

Persistent Volumes and Claims work in conjunction to serve as the direct method in which a Pod Consumes Persistent
storage.

A `PersistentVolume` (PV) is a representation of a cluster-wide storage resource that is linked to a backing storage
provider - `NFS`, `GCEPersistentDisk`, `RBD` etc.

A `PersistentVolumeClaim` acts as a namespaced _request_ for storage that satisfies a set of a requirements instead
of mapping to the storage resource directly.


This separation of PV and PVC ensures that an application’s _‘claim’_ for storage is portable across numerous backends
 or providers.

---

### Exercise: Understanding Persistent Volumes and Claims
**Objective:** Gain an understanding of the relationship between `PersistentVolume` and `PersistentVolumeClaim`. Then
explore how they're consumed by a Pod.

---

1) Create pv `pv-sc-example` from the manifest `manifests/pv-example.yaml` or use the yaml below. Ensure to note that its
Storage Class Name is set to `mypvsc`.

**Command:**
```
$ kubectl create -f manifests/pv-sc-example.yaml
```

**manifests/pv-example.yaml**
```
kind: PersistentVolume
apiVersion: v1
metadata:
  name: pv-sc-example
  labels:
    type: hostpath
spec:
  capacity:
    storage: 2Gi
  accessModes:
    - ReadWriteMany
  storageClassName: mypvsc
  hostPath:
    type: DirectoryOrCreate
    path: "/data/mypvsc"
```

2) Once created

---

**Summary:**

---

[Back to Index](#index)

---
---


# Persistent Volume Claims

Content Here

---

### Exercise: Using PersistentVolumeClaims
**Objective:**

---

**Summary:**

---

[Back to Index](#index)

---

### Exercise: Using PersistentVolumeClaims
**Objective:**

---

1)
```
Content Here
```

---

**Summary:**

---

[Back to Index](#index)

---
---

# Storage Classes

Content Here

---

### Exercise: Exploring StorageClasses
**Objective:**

---

1)
```
Content Here
```

---

**Summary:**

---

[Back to Index](#index)

---
---

# Cleaning Up

Content Here

---

[Back to Index](#index)

---
---

# Helpful Resources

Content here


---

[Back to Index](#index)
